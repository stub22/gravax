package fun.gravax.dsktch.quantile

/***
 * API for accessing sketch result.
 * Initial design is based on ItemsSketch from the Apache DataSketches project.
 * https://datasketches.apache.org/api/java/snapshot/apidocs/org/apache/datasketches/quantiles/ItemsSketch.html
 * @tparam T
 *
 * This reader is able to read a sinigle fixed immutable sketch.
 * All data passed in+out of this reader's methods should be treated as immutable, by both the impl and the client.
 */
trait QuantileSketchReader[T] {
	// Encode the assumption that "Double" is used for rank+fraction numbering.
	type RealNum = Double

	// Returns the configured value of K (which roughly means:  the number of approximation bins used)
	def getK: Int

	// Returns the length of the input stream used to create this sketch, i.e. the number of samples seen.
	def getN : Long
	def isEmpty: Boolean

	// Fetch the number of *retained* samples in the sketch.
	def getRetainedItems: Int
	def getMaxValue: T
	def getMinValue: T

	// Returns an approximation to the normalized (fractional) rank of the given value from 0 to 1 inclusive.
	def getRank(t : T) : RealNum

	// This returns an approximation to the value of the data item that would be preceded by the given fraction of a hypothetical sorted version of the input stream so far.
	def getQuantile(fraction : RealNum): T

	// Gets the lower bound of the value interval in which the true quantile of the given rank exists with a confidence of at least 99%.
	def getQuantileLowerBound(fraction : RealNum): T

	// Gets the upper bound of the value interval in which the true quantile of the given rank exists with a confidence of at least 99%.
	def getQuantileUpperBound(fraction : RealNum): T

	// Gets the approximate rank error of this sketch normalized as a fraction between zero and one.
	// pmf: if true, returns the "double-sided" normalized rank error for the getPMF() function.
	// Otherwise, it is the "single-sided" normalized rank error for all the other queries.
	def getNormalizedRankError(pmf : Boolean) : RealNum

	def getSummaryTxt(flg_includeSketchSummary: Boolean, flg_includeDataDetail: Boolean) : String

	// In Scala 2.13+, Seq means scala.collection.immutable.Seq

	// The methods above use scalar inputs+outputs, and hence are automatically immutable.
	// The methods below use collections, which we treat more carefully.
	type InSeqT = Seq[T]
	type OutSeqT = Seq[T]
	type InSeqRN = Seq[RealNum]
	type OutSeqRN = Seq[RealNum]

	/* getPMF     https://datasketches.apache.org/api/java/snapshot/apidocs/org/apache/datasketches/quantiles/ItemsSketch.html
	public double[] getPMF(T[] splitPoints)
	Returns an approximation to the Probability Mass Function (PMF) of the input stream given a set of splitPoints (values).
	The resulting approximations have a probabilistic guarantee that be obtained from the getNormalizedRankError(true) function.
	If the sketch is empty this returns null.
	Parameters:
	splitPoints - an array of m unique, monotonically increasing item values that divide the ordered space into m+1 consecutive disjoint intervals. The definition of an "interval" is inclusive of the left splitPoint (or minimum value) and exclusive of the right splitPoint, with the exception that the last interval will include the maximum value. It is not necessary to include either the min or max values in these splitpoints.
	Returns:
	an array of m+1 doubles each of which is an approximation to the fraction of the input stream values (the mass) that fall into one of those intervals. The definition of an "interval" is inclusive of the left splitPoint and exclusive of the right splitPoint, with the exception that the last interval will include maximum value.
	 */
	def getPMF(splitPoints: InSeqT): OutSeqRN

	/* getCDF     https://datasketches.apache.org/api/java/snapshot/apidocs/org/apache/datasketches/quantiles/ItemsSketch.html
Returns an approximation to the Cumulative Distribution Function (CDF), which is the cumulative analog of the PMF, of the input stream given a set of splitPoints (values).
The resulting approximations have a probabilistic guarantee that be obtained from the getNormalizedRankError(false) function.
If the sketch is empty this returns null.
The value at array position j of the returned CDF array is the sum of the returned values in positions 0 through j of the returned PMF array.
	*/
	def getCDF(splitPoints: InSeqT): OutSeqRN

	/*
	This is a more efficient multiple-query version of getQuantile().
	This returns an array that could have been generated by using getQuantile() with many different fractional ranks, but would be very inefficient. This method incurs the internal set-up overhead once and obtains multiple quantile values in a single query. It is strongly recommend that this method be used instead of multiple calls to getQuantile().
	If the sketch is empty this returns null.
	Parameters:
	fRanks - the given array of fractional (or normalized) ranks in the hypothetical sorted stream of all the input values seen so far.
	These fRanks must all be in the interval [0.0, 1.0] inclusively.
	Returns:
	array of approximate quantiles of the given fRanks in the same order as in the given fRanks array.
	 */
	def getQuantiles(fRanks : InSeqRN): OutSeqT

	/*
	evenlySpaced - an integer that specifies the number of evenly spaced fractional ranks.
	This must be a positive integer greater than 1. A value of 2 will return the min and the max value.
	A value of 3 will return the min, the median and the max value, etc.
	*/
	def getRegularQuantiles(evenlySpaced : Int): OutSeqT
}


class SketchDumperForBigDecimal(qsr : QuantileSketchReader[BigDecimal]) {
	def getDetailedTxt(numQuantiles : Int, numProbBins : Int, flg_SketchInfo : Boolean, flg_dataDetail : Boolean) : String = {
		val summTxt = qsr.getSummaryTxt(flg_SketchInfo, flg_dataDetail)
		val qSeq: qsr.OutSeqT = qsr.getRegularQuantiles(numQuantiles)
		val quantTxt = qSeq.toList.toString
		val (minV, maxV) = (qsr.getMinValue, qsr.getMaxValue)
		val width = maxV.-(minV)
		val binCnt = numProbBins
		val incr = width./(binCnt)
		val binIdxs = 1 to binCnt - 1
		val splits: Array[BigDecimal] = binIdxs.toSeq.map(idx => incr.*(idx).+(minV)).toArray
		val pmf: qsr.OutSeqRN = qsr.getPMF(splits)
		val pmfSum = pmf.reduce(_ + _)
		val splitsTxt = splits.toList.toString()
		val pmfTxt = pmf.toList.toString()
		val statTxts = List(summTxt, "quants: " + quantTxt, "splits: " + splitsTxt, "pmf: " + pmfTxt, "pmfSum:" + pmfSum)
		statTxts.mkString("\n")
	}
}
